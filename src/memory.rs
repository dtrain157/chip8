use std::error;
use std::fmt;

pub const MEMORY_SIZE: usize = 4096; //support 4k of memory

pub const FONT_CHARACTERS: [u8; 80] = [
    0xF0, 0x90, 0x90, 0x90, 0xF0, //"0" Character
    0x20, 0x60, 0x20, 0x20, 0x70, //"1" Character
    0xF0, 0x10, 0xF0, 0x80, 0xF0, //"2" Character
    0xF0, 0x10, 0xF0, 0x10, 0xF0, //"3" Character
    0x90, 0x90, 0xF0, 0x10, 0x10, //"4" Character
    0xF0, 0x80, 0xF0, 0x10, 0xF0, //"5" Character
    0xF0, 0x80, 0xF0, 0x90, 0xF0, //"6" Character
    0xF0, 0x10, 0x20, 0x40, 0x40, //"7" Character
    0xF0, 0x90, 0xF0, 0x90, 0xF0, //"8" Character
    0xF0, 0x90, 0xF0, 0x10, 0xF0, //"9" Character
    0xF0, 0x90, 0xF0, 0x90, 0x90, //"A" Character
    0xE0, 0x90, 0xE0, 0x90, 0xE0, //"B" Character
    0xF0, 0x80, 0x80, 0x80, 0xF0, //"C" Character
    0xE0, 0x90, 0x90, 0x90, 0xE0, //"D" Character
    0xF0, 0x80, 0xF0, 0x80, 0xF0, //"E" Character
    0xF0, 0x80, 0xF0, 0x80, 0x80, //"F" Character
];

pub const PONG: [u8; 256] = [
    0x6A, 0x02, 0x6B, 0x0C, 0x6C, 0x3F, 0x6D, 0x0C, 0xA2, 0xEA, 0xDA, 0xB6, 0xDC, 0xD6, 0x6E, 0x00, 0x22, 0xD4, 0x66, 0x03, 0x68, 0x02, 0x60, 0x60, 0xF0, 0x15, 0xF0, 0x07, 0x30,
    0x00, 0x12, 0x1A, 0xC7, 0x17, 0x77, 0x08, 0x69, 0xFF, 0xA2, 0xF0, 0xD6, 0x71, 0xA2, 0xEA, 0xDA, 0xB6, 0xDC, 0xD6, 0x60, 0x01, 0xE0, 0xA1, 0x7B, 0xFE, 0x60, 0x04, 0xE0, 0xA1,
    0x7B, 0x02, 0x60, 0x1F, 0x8B, 0x02, 0xDA, 0xB6, 0x60, 0x0C, 0xE0, 0xA1, 0x7D, 0xFE, 0x60, 0x0D, 0xE0, 0xA1, 0x7D, 0x02, 0x60, 0x1F, 0x8D, 0x02, 0xDC, 0xD6, 0xA2, 0xF0, 0xD6,
    0x71, 0x86, 0x84, 0x87, 0x94, 0x60, 0x3F, 0x86, 0x02, 0x61, 0x1F, 0x87, 0x12, 0x46, 0x02, 0x12, 0x78, 0x46, 0x3F, 0x12, 0x82, 0x47, 0x1F, 0x69, 0xFF, 0x47, 0x00, 0x69, 0x01,
    0xD6, 0x71, 0x12, 0x2A, 0x68, 0x02, 0x63, 0x01, 0x80, 0x70, 0x80, 0xB5, 0x12, 0x8A, 0x68, 0xFE, 0x63, 0x0A, 0x80, 0x70, 0x80, 0xD5, 0x3F, 0x01, 0x12, 0xA2, 0x61, 0x02, 0x80,
    0x15, 0x3F, 0x01, 0x12, 0xBA, 0x80, 0x15, 0x3F, 0x01, 0x12, 0xC8, 0x80, 0x15, 0x3F, 0x01, 0x12, 0xC2, 0x60, 0x20, 0xF0, 0x18, 0x22, 0xD4, 0x8E, 0x34, 0x22, 0xD4, 0x66, 0x3E,
    0x33, 0x01, 0x66, 0x03, 0x68, 0xFE, 0x33, 0x01, 0x68, 0x02, 0x12, 0x16, 0x79, 0xFF, 0x49, 0xFE, 0x69, 0xFF, 0x12, 0xC8, 0x79, 0x01, 0x49, 0x02, 0x69, 0x01, 0x60, 0x04, 0xF0,
    0x18, 0x76, 0x01, 0x46, 0x40, 0x76, 0xFE, 0x12, 0x6C, 0xA2, 0xF2, 0xFE, 0x33, 0xF2, 0x65, 0xF1, 0x29, 0x64, 0x14, 0x65, 0x00, 0xD4, 0x55, 0x74, 0x15, 0xF2, 0x29, 0xD4, 0x55,
    0x00, 0xEE, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

const FONT_CHARACTER_SIZE: usize = 5; //size in bytes

pub struct Memory {
    memory: [u8; MEMORY_SIZE],
}

impl Memory {
    pub fn new() -> Self {
        let mut mem = Memory { memory: [0; MEMORY_SIZE] };
        mem.clear();
        mem
    }

    pub fn clear(&mut self) {
        self.memory = [0; MEMORY_SIZE];
        for i in 0..FONT_CHARACTERS.len() {
            self.memory[i] = FONT_CHARACTERS[i];
        }

        // pre-loading the programme code for PONG into memory, for testing
        for j in 0..PONG.len() {
            self.memory[j + 0x200] = PONG[j];
        }
    }

    pub fn read_word(&self, index: usize) -> Result<u16, MemoryError> {
        let first_byte = self.memory.get(index);
        let second_byte = self.memory.get(index + 1);

        match (first_byte, second_byte) {
            (Some(b1), Some(b2)) => {
                let data = ((*b1 as u16) << 8) | (*b2 as u16);
                return Ok(data);
            }
            _ => return Err(MemoryError::InvalidAddress(index)),
        }
    }

    pub fn read_byte(&self, index: usize) -> Result<u8, MemoryError> {
        let byte = self.memory.get(index);

        match byte {
            Some(byte) => Ok(*byte),
            _ => return Err(MemoryError::InvalidAddress(index)),
        }
    }

    pub fn read_multiple_bytes(&self, index: usize, bytes: u8) -> Result<&[u8], MemoryError> {
        let from = index;
        let to = index + (bytes as usize);
        if (from + to) >= MEMORY_SIZE {
            return Err(MemoryError::InvalidAddress(from + to));
        }
        Ok(&self.memory[from..to])
    }

    pub fn write_byte(&mut self, index: usize, byte: u8) -> Result<(), MemoryError> {
        if (index as usize) >= MEMORY_SIZE {
            return Err(MemoryError::InvalidAddress(index));
        }
        self.memory[index as usize] = byte;
        Ok(())
    }

    pub fn get_location_of_font_character(&self, character: u8) -> usize {
        (character as usize) * FONT_CHARACTER_SIZE
    }
}

#[derive(Debug)]
pub enum MemoryError {
    InvalidAddress(usize),
}

impl fmt::Display for MemoryError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            MemoryError::InvalidAddress(addr) => write!(f, "Tried to read from an invalid address in the memory: {:#04X}!", addr),
        }
    }
}

impl error::Error for MemoryError {}

#[cfg(test)]
mod memory_tests {
    use super::*;

    #[test]
    fn memory_read_word() {
        let mut mem = Memory::new();
        mem.memory[0] = 1 as u8;
        mem.memory[1] = 2 as u8;
        let data = mem.read_word(0).unwrap();
        assert_eq!(data, 0x102);
    }

    #[test]
    fn memory_read_multiple_bytes() {
        let mut mem = Memory::new();
        mem.memory[1] = 2 as u8;
        mem.memory[2] = 3 as u8;
        mem.memory[3] = 4 as u8;
        mem.memory[4] = 5 as u8;

        let expected_result = vec![240, 2, 3, 4, 5];
        let actual_result = mem.read_multiple_bytes(0, 5).unwrap();
        assert!(expected_result.len() == actual_result.len() && expected_result == actual_result);
    }

    #[test]
    fn memory_write_byte() {
        let mut mem = Memory::new();
        mem.write_byte(1, 0x5).unwrap();
        mem.write_byte(2, 0x6).unwrap();
        let data1 = mem.read_byte(1).unwrap();
        let data2 = mem.read_byte(2).unwrap();
        assert_eq!(data1, 0x5);
        assert_eq!(data2, 0x6);
    }
}
